<!DOCTYPE html>
<html><head>
<title>Chapter 1 - Getting Started</title>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-combined.min.css" rel="stylesheet">
<link href="style.css" rel="stylesheet">
</head>
<body>
<div class="container">
    <div class="row">
        <div class="offset2 span8">
<p>Chapter 1</p>

<h1>Getting Started</h1>

<p><a href="index.html">Top</a></p>

<h2>What is Marpa?</h2>

<p>Marpa is parser library written in Perl and C. It gives you a way to convert
text to a structure based on any BNF. During the parsing Marpa knows what
tokens it expects next and allows you to guide the parse in the right
direction.</p>

<h2>Getting the code</h2>

<p>Marpa is a Perl library. We will use
<a href="http://metacpan.org/dist/Marpa-R2">Marpa::R2</a> for the examples in this guide.</p>

<p>If you have Perl already installed you can install Marpa with <code>cpan</code> or <code>cpanm</code>.</p>

<pre class="prettyprint linenums"><code>$ cpan Marpa::R2
</code></pre>

<p>or</p>

<pre class="prettyprint linenums"><code>$ cpanm Marpa::R2
</code></pre>

<p>This will install Marpa::R2.</p>

<p>In the rest of this guide we'll assume you have installed Marpa::R2. The examples
that end in '.pl' can be executed.</p>

<h2>First example</h2>

<p>Let's start with an example. What follows is the smallest code that parses a
list of numbers.</p>

<pre class="prettyprint linenums"><code>use strict;
use Marpa::R2;
use Data::Dumper;

my $g = Marpa::R2::Scanless::G-&gt;new({
        default_action =&gt; '::first',
        source         =&gt; \(&lt;&lt;'END_OF_SOURCE'),

:start        ::= numbers
numbers       ::= number+            action =&gt; ::array
number          ~ [\d]+
:discard        ~ ws
ws              ~ [\s]+

END_OF_SOURCE
});

my $re = Marpa::R2::Scanless::R-&gt;new({ grammar =&gt; $g });
my $input = "1 3 5 8 13 21 34 55";

print "Trying to parse:\n$input\n\n";
$re-&gt;read(\$input);
my $value = ${$re-&gt;value};
print "Output:\n".Dumper($value);
</code></pre>

<p class='example-filename'><a href='examples/number.pl'>examples/number.pl</a></p>

<p>In this example we parse a few numbers separated by spaces. Let's run the code first.
You can run the code by calling it with <code>perl</code>.</p>

<pre class="prettyprint linenums"><code>$ perl number.pl
Trying to parse:
1 3 5 8 13 21 34 55

Output:
$VAR1 = [
    '1',
    '3',
    '5',
    '8',
    '13',
    '21',
    '34',
    '55'
];
</code></pre>

<p>The example shows which text it tries to parse followed by the array that it
found.</p>

<p>In the next sections we'll just show the notation used by Marpa. The examples
contain the full code.</p>

<pre class="prettyprint linenums"><code>:start        ::= numbers
numbers       ::= number+            action =&gt; ::array
number          ~ [\d]+
:discard        ~ ws
ws              ~ [\s]+
</code></pre>

<p class='example-filename'><a href='examples/number2.pl'>examples/number2.pl</a></p>

<p>In the specification language that Marpa uses, the <code>:start</code> rule specifies
which rule is the top most rule that should match. The declaration operator
<code>::=</code> separates the name of the rule, on left side, from the specification, on the right side.</p>

<p>The symbol on the left side of the declaration operator is the name of the
rule. The symbols on the right side of the operator specify what it matches
to.</p>

<p>According to the <code>:start</code> declaration Marpa will start to parse from the
<code>numbers</code> rule. The <code>numbers</code> rule contains <code>number</code> followed by a <code>+</code>
operator. The <code>+</code> operator lets Marpa know that we expect one or more <code>number</code>
lexemes.</p>

<p>The next line specifies what a number looks like. The <code>~</code> operator separates the name of the token
from the character class on the right. We specify <code>number</code> to be one or more digits. Marpa uses the 
same character classes as Perl does internally.</p>

<p>Then we specify a <code>:discard</code> rule. With this we can specify what tokens Marpa can discard. The input language contains whitespace between the numbers. With the <code>ws</code> rule we say what this looks like.</p>

<p>This grammar will parse input strings like this following.</p>

<pre class="prettyprint linenums"><code>123    9 45 83 1000 1001          39201
</code></pre>

<p>The input string with numbers could be much longer than this as long as each
number is separated by one or more whitespace characters. This includes spaces,
tabs and newlines.</p>

<h3>Lexical rules</h3>

<p>The rules <code>ws</code> and <code>number</code> are examples of lexical rules. A lexical rule
specifies which characters can be matched in the input string. A lexical rule
can contain character classes and quoted strings.</p>

<p>A character class specifies each character or group of characters that can be
matched. These character classes are evaluated by Perl. This means that
everything that would work in Perl itself, can be used in a Marpa character
class. We already saw how to match a number. This is how you could match a
variable name.</p>

<pre class="prettyprint linenums"><code>identifier      ~ [_a-zA-Z] id_rest
id_rest         ~ [_0-9a-zA-Z]*
</code></pre>

<p class='example-filename'><a href='examples/identifier.pl'>examples/identifier.pl</a></p>

<p>The rule for matching an identifier (or name) is split into two rules. The first
rule specifies the structure of the token. The first part of it matches the
first character of an identifier. It can be an underscore, a lowercase
character or an uppercase character. It can't be a number however. <br />
The second part <code>id_rest</code> references the second rule, which specifies the
rest of the identifier. This can include numbers as well. The asterisk <code>*</code> at the
end says that this character class can match zero of more times.</p>

<p>The asterisk is also the reason why we split the identifier rule into two
parts. The asterisk can only be used on rules with a single item on the right
hand side.</p>

<p>A lexical rule can also use a quoted string. A quoted string are surrounded
with single quotes <code>'</code>. The text between the quotes will match as literal text.
You could use this for single characters or keywords.</p>

<pre class="prettyprint linenums"><code>kw_for    ~ 'for'
kw_if     ~ 'if'
</code></pre>

<h3>Keywords</h3>

<p>Let's take a look at a small declarative part of a language with two keywords: 'Deny', 'Allow'.</p>

<pre class="prettyprint linenums"><code>Deny baduser
Allow admin
</code></pre>

<p>The semantics (or meaning) of the language could be anything. Parsing the
language can be really easy with Marpa.</p>

<pre class="prettyprint linenums"><code>:start        ::= rules
rules         ::= rule+

rule          ::= cmd_type username

cmd_type        ~ 'Deny' | 'Allow'
username        ~ [\w]+

:discard        ~ ws
ws              ~ [\s]+
</code></pre>

<p class='example-filename'><a href='examples/deny-allow.pl'>examples/deny-allow.pl</a></p>

<pre class="prettyprint linenums"><code>Trying to parse:
Deny baduser
Allow admin

Output:
$VAR1 = [
    [
        'Deny',
        'baduser'
    ],
    [
        'Allow',
        'admin'
    ]
];
</code></pre>

<p>The output shows that Marpa find parsed two rules. The first rule with the
'Deny' keyword and the second with the 'Allow' keyword. It seems that the
keywords could interfere with the usernames. The <code>cmd_type</code>s are a subset of
the usernames.</p>

<p>Let's see what happens when we change the first username from baduser to Allow.
Can Marpa see the difference between keywords and usernames?</p>

<pre class="prettyprint linenums"><code>Output:
$VAR1 = [
    [
        'Deny',
        'Allow'
    ],
    [
        'Allow',
        'admin'
    ]
];
</code></pre>

<p>It doesn't matter that the first username matches a <code>cmd_type</code>. Marpa knows
that the word 'Allow' could also be a username.</p>

<p>Now let's see what happens when we an input that doesn't match by switching
around the username and the keyword. Keyword could be username, but the other
way around they can't be.</p>

<p>I change the input to:</p>

<pre class="prettyprint linenums"><code>baduser Deny 
admin Allow
</code></pre>

<p>When we run the examples we get the following output:</p>

<pre class="prettyprint linenums"><code>Error in SLIF G1 read: No lexemes accepted at position 0
* String before error: baduser
* The error  was at line 1, column 8, and at character 0x0020 (non-graphic character), ...
* here:  Deny\nadmin Allow\n
Marpa::R2 exception at examples/deny-allow.pl line 33.
</code></pre>

<p>Marpa tries to point to the error as best as it can. Marpa starts with the
problem: <code>No lexemes accepted at position 0</code>. This is Marpa's way of teling us
that Marpa couldn't find a way to match <code>baduser</code> to one of the expected
lexemes, <code>Deny</code> or <code>Allow</code>. </p>

<h3>More syntax</h3>

<p>Now let's add a way to specify groups of users. The syntax could look like this.</p>

<pre class="prettyprint linenums"><code>admins = admin root
Deny baduser
Allow @admins
</code></pre>

<p>The first line specifies a list of admin users. The second line stays the same
and the third line contains a reference to the <code>admins</code> list of users. The <code>@</code>
operators makes it a reference.</p>

<p>We start by changing the input in the file. We run the code and find that it
doesn't parse. Of course we didn't expect that. </p>

<p>Now we need to add a rule for parsing the <code>admins = ...</code> line.</p>

<p>In this case <code>admins</code> is similar to a username so let's use that.</p>

<pre class="prettyprint linenums"><code>user_list  ::= username '=' username username
</code></pre>

<p>This line should work, let's try it. We add it in the grammar. Let's add it to the 
<code>rule</code> rule as an alternative. We use the <code>|</code> (or) operator. Let's try it.</p>

<pre class="prettyprint linenums"><code>rule    ::= cmd_type username
          | user_list
</code></pre>

<p>When we run this code we get the following:</p>

<pre class="prettyprint linenums"><code>Lexing failed at unacceptable character 0x0040 '@'
Marpa::R2 exception at examples/deny-allow2.pl line 37.
</code></pre>

<p>Marpa doesn't like the '@' character in the third line. Let's add that.
We add another line to <code>rule</code>. The reference is like a username.</p>

<pre class="prettyprint linenums"><code>rule          ::= cmd_type username
                | cmd_type '@' username
                | user_list
</code></pre>

<p class='example-filename'><a href='examples/deny-allow2.pl'>examples/deny-allow2.pl</a></p>

<p>When we run it the parse succeeds, but the result is not completely right.</p>

<pre class="prettyprint linenums"><code>[
    'Allow',
    '@',
    'admins'
]
</code></pre>

<p>The <code>@</code> and <code>admins</code> is parsed in two parts. We like the reference to be a single
thing. We change this be making a lexical rule for the <code>list_ref</code>.</p>

<pre class="prettyprint linenums"><code>rule          ::= cmd_type username
                | cmd_type list_ref
                | user_list

list_ref        ~ '@' username
</code></pre>

<p class='example-filename'><a href='examples/deny-allow3.pl'>examples/deny-allow3.pl</a></p>

<p>Now let's run <code>deny-allow3.pl</code>.</p>

<pre class="prettyprint linenums"><code>Symbol &lt;username&gt; is a lexeme in G1, but not in G0.
  This may be because &lt;username&gt; was used on a RHS in G0.
  A lexeme cannot be used on the RHS of a G0 rule.
Marpa::R2 exception at examples/deny-allow3.pl line 6.
</code></pre>

<p>This gives us a look into the inner workings of Marpa. This error message says
that we can't use a lexeme in both the structural rules (G1) and lexical rules
(G0). We need to create two lexical rules: one for <code>rule</code> and <code>user_list</code> and
one for <code>list_ref</code>.</p>

<pre class="prettyprint linenums"><code>rule          ::= cmd_type user
                | cmd_type list_ref
                | user_list

user_list  ::= user '=' user user

list_ref        ~ '@' username
user            ~ username
</code></pre>

<p class='example-filename'><a href='examples/deny-allow4.pl'>examples/deny-allow4.pl</a></p>

<p>With these changes we can parse the input without problems. The output shows
what we expected.</p>

<h3>Multiple users</h3>

<p>Even though the code works, it could be that you saw a problem with this. Ask
yourself what would happen if you specify more or less than two users on the
right side of a <code>user_list</code>? Try it.</p>

<p>The parser doesn't know what to do with the extra user in the list.
Let's change <code>user_list</code> to allow multiple users.</p>

<pre class="prettyprint linenums"><code>user_list  ::= user '=' users
users      ::= user+
</code></pre>

<p class='example-filename'><a href='examples/deny-allow5.pl'>examples/deny-allow5.pl</a></p>

<h3>Exercise</h3>

<ol>
<li><p><strong>Multiple users</strong> &mdash; Change the grammar to allow multiple users on the <code>Allow</code> or <code>Deny</code> line. For example:</p>

<pre class="prettyprint linenums"><code>Allow root admin
Deny baduser cracker
</code></pre></li>
</ol>
        </div>
    </div>
    <div class="row footer">
        <div class="offset2 span8">
            <p>
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="float:left; margin-right:12px; border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Marpa Guide</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Peter Stuifzand and Contributors</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a> and the <a rel="license" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3</a></p>
        </div>
    </div>
</div>
<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
</body></html>
